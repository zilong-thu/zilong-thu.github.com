<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    
    <title>《JavaScript语言精粹》笔记 | 王子龙的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="《JavaScript语言精粹》 伯乐在线 - 给JavaScript初学者的24条最佳实践">
<meta property="og:type" content="article">
<meta property="og:title" content="《JavaScript语言精粹》笔记">
<meta property="og:url" content="https://borninsummer.com/2014/01/02/reading-notes-on-javascript-the-good-parts/index.html">
<meta property="og:site_name" content="王子龙的博客">
<meta property="og:description" content="《JavaScript语言精粹》 伯乐在线 - 给JavaScript初学者的24条最佳实践">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://borninsummer.com/images/blog/javascript/20140102/where_do_javascript_comes.PNG">
<meta property="article:published_time" content="2014-01-02T06:37:00.000Z">
<meta property="article:modified_time" content="2025-03-13T02:58:40.147Z">
<meta property="article:author" content="zilong-thu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://borninsummer.com/images/blog/javascript/20140102/where_do_javascript_comes.PNG">
    

    
        <link rel="alternate" href="/" title="王子龙的博客" type="application/atom+xml" />
    

    
        <link rel="icon" href="/favicon.png" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">


    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
    
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-45360338-1', 'auto');
ga('send', 'pageview');

</script>
    
    
    
        <script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?73ca1d91f31b2463befdc1c1827f2576";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>

    



    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1653521488348699"
      crossorigin="anonymous"
    ></script>
<meta name="generator" content="Hexo 5.0.0"></head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">王子龙的博客</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
                    <a class="main-nav-link" href="/donate">Donate</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="https://borninsummer.com"></form>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                    <td><a class="main-nav-link" href="/donate">Donate</a></td>
                
                <td>
                    
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="https://borninsummer.com"></form>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            <ins class="adsbygoogle"
  style="display:block; text-align:center;"
  data-ad-layout="in-article"
  data-ad-format="fluid"
  data-ad-client="ca-pub-1653521488348699"
  data-ad-slot="8991168856"
></ins>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({});
</script>
            
            <section id="main"><article id="post-reading-notes-on-javascript-the-good-parts" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            《JavaScript语言精粹》笔记
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2014/01/02/reading-notes-on-javascript-the-good-parts/">
            <time datetime="2014-01-02T06:37:00.000Z" itemprop="datePublished">2014-01-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
    </div>

                        
                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            <div id="toc" class="toc-article">
                <strong class="toc-title">Catalogue</strong>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">第3章 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2"><span class="toc-number">1.1.</span> <span class="toc-text">检索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">原型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">第4章 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%EF%BC%88Invocation%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">调用（Invocation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">函数调用模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">构造器调用模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Apply%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">Apply调用模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.3.</span> <span class="toc-text">关于返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">2.4.</span> <span class="toc-text">扩展类型的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%EF%BC%88Recursion%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">递归（Recursion）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94"><span class="toc-number">2.5.1.</span> <span class="toc-text">汉诺塔</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM%E9%81%8D%E5%8E%86"><span class="toc-number">2.5.2.</span> <span class="toc-text">DOM遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96"><span class="toc-number">2.5.3.</span> <span class="toc-text">尾递归优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%EF%BC%88Closure%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">闭包（Closure）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%EF%BC%88Module%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">模块（Module）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96%EF%BC%88curry%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">柯里化（curry）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%EF%BC%88Memoization%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">记忆（Memoization）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">第5章 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">伪类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-1"><span class="toc-number">3.2.</span> <span class="toc-text">原型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">第6章 数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">第7章 正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E6%96%B9%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">第8章 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">7.</span> <span class="toc-text">第9章 代码风格</span></a></li></ol>
            </div>
            <p><a href="http://book.douban.com/subject/3590768/" class="douban_book" name="3590768" target="_blank" title="《JavaScript语言精粹》">《JavaScript语言精粹》</a></p>
<p><a href="http://blog.jobbole.com/53199/" target="_blank">伯乐在线 - 给JavaScript初学者的24条最佳实践</a></p>
<img src="/images/blog/javascript/20140102/where_do_javascript_comes.PNG" title="JavaScript语言特性来源">

<a id="more"></a>

<h2 id="第3章-对象"><a href="#第3章-对象" class="headerlink" title="第3章 对象"></a>第3章 对象</h2><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><p>优先考虑使用<code>.</code>表示法，因为它更紧凑且可读性更好。</p>
<p>尝试从<code>undefined</code>的成员属性中取值将会导致TypeError异常，这时可以通过<code>&amp;&amp;</code>运算符来避免错误。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>对象通过引用来传递。它们永远不会被复制。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>Prototype</p>
<p>所有通过对象字面量创建的对象都连接到<code>Object.prototype</code>，它是JavaScript中的标配对象。</p>
<p>原型连接在更新时是不起作用的。当我们对某个对象做出改变时，不会触及该对象的原型。原型链只有在检索值的时候才被用到。</p>
<figure class="highlight javascript"><figcaption><span>使用某对象作为原型创建新对象</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">&#x27;function&#x27;</span>)&#123;   <span class="comment">// 此处中文版有错误，不知为何，Object.create被印刷成Object.beget。可参加英文原版</span></span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">        F.prototype = o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">&#x27;first-name&#x27;</span>: <span class="string">&#x27;Zilong&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;last-name&#x27;</span> : <span class="string">&#x27;Wang&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span> : <span class="number">25</span>,</span><br><span class="line">    <span class="attr">sayName</span>     : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span>+ <span class="built_in">this</span>[<span class="string">&#x27;first-name&#x27;</span>] + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>[<span class="string">&#x27;last-name&#x27;</span>] + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以person对象为原型的新对象</span></span><br><span class="line"><span class="keyword">var</span> another_person = <span class="built_in">Object</span>.create(person);</span><br><span class="line"></span><br><span class="line">another_person.sayName();                <span class="comment">// =&gt; My name is Zilong Wang.</span></span><br><span class="line">another_person[<span class="string">&#x27;first-name&#x27;</span>] = <span class="string">&#x27;San&#x27;</span>;</span><br><span class="line">another_person[<span class="string">&#x27;last-name&#x27;</span>] = <span class="string">&#x27;Zhang&#x27;</span>;</span><br><span class="line"></span><br><span class="line">another_person.sayName();                <span class="comment">// =&gt; My name is San Zhang.</span></span><br><span class="line">person.sayName();                        <span class="comment">// =&gt; My name is Zilong Wang.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对原型的更新会立即对所有基于此原型创建的对象可见</span></span><br><span class="line">person.address = <span class="string">&#x27;Beijing&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(another_person.address);     <span class="comment">// =&gt; Beijing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不过在检查自有属性的时候，address并不在another_person中</span></span><br><span class="line"><span class="comment">// hasOwnProperty方法不会检查原型链</span></span><br><span class="line"><span class="built_in">console</span>.log(another_person.hasOwnProperty(<span class="string">&#x27;address&#x27;</span>));      <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<h2 id="第4章-函数"><a href="#第4章-函数" class="headerlink" title="第4章 函数"></a>第4章 函数</h2><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><blockquote>
<p>JavaScript设计得最出色的就是它的函数的实现。它几乎接近完美。但是，想必你也能预料到，JavaScript的函数也存在瑕疵。</p>
</blockquote>
<p>JavaScript中的函数就是对象。对象是“名/值”对的几何并拥有一个连接到原型对象的隐藏连接。对象字面量产生的对象连接到<code>Object.prototype</code>。函数对象连接到<code>Function.prototype</code>（该对象本身连接到<code>Object.prototype</code>）。每个函数在创建时会附加两个隐藏属性：函数的上下文和实现函数行为的代码。</p>
<p>这里涉及的原型链如下图所示。</p>
<embed src="/images/blog/javascript/20140102/prototype_chain.svg" type="image/svg+xml">

<p>另外，每个函数在创建时也随配有一个<code>prototype</code>属性。它的值是一个拥有<code>constructor</code>属性且值即为该函数的对象。这和隐藏连接到<code>Function.prototype</code>完全不同。</p>
<p>一个内部函数除了可以访问自己的参数和变量，同时它也能自由访问把它嵌套在其中的付函数的参数与变量。通过函数字面量创建的函数对象包含一个连到外部上下文的连接。这被称为闭包（closure）。它是JavaScript强大表现力的来源。</p>
<h3 id="调用（Invocation）"><a href="#调用（Invocation）" class="headerlink" title="调用（Invocation）"></a>调用（Invocation）</h3><p>JavaScript一共有4种函数调用模式：</p>
<ul>
<li>方法调用模式（the method invocation pattern）</li>
<li>函数调用模式（the function invocation pattern）</li>
<li>构造器调用模式（the constructor invocation function）</li>
<li>apply调用模式（the apply invocation pattern）</li>
</ul>
<p>伴随着不同的调用方式，<code>this</code>也会指向不同的对象。</p>
<h4 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h4><p>函数调用模式下（函数不作为对象的方法），this指向全局对象。在浏览器中，就是window对象。</p>
<p>*这是JavaScript语言设计上的一个错误。</p>
<h4 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h4><p>如果在一个函数前面带上 <code>new</code> 来调用，那么背地里将会创建一个连接到该函数的<code>prototype</code>成员的新对象，同时<code>this</code>将被绑定到那个新对象上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Quo = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.status = string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 Quo.prototype 是所有用 new 关键字来调用时创建的新对象的原型</span></span><br><span class="line"><span class="comment">// 所以，这样给Quo的所有实例提供一个名为 get_status 的公共方法：</span></span><br><span class="line">Quo.prototype.get_status = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.status);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myQuo = <span class="keyword">new</span> Quo(<span class="string">&quot;confused&quot;</span>);</span><br><span class="line"></span><br><span class="line">myQuo.get_status();                 <span class="comment">// =&gt; confused</span></span><br></pre></td></tr></table></figure>

<p><strong>我的感觉是：通过构造器函数实现继承的方式，是提供给那些无法接受原型继承思想的程序员来用的。</strong>JavaScript风格的“构造函数”应该是闭包（Closure）形式的、不使用new关键字。</p>
<h4 id="Apply调用模式"><a href="#Apply调用模式" class="headerlink" title="Apply调用模式"></a>Apply调用模式</h4><p>函数是对象，所以函数可以拥有方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> sum = add.apply(<span class="literal">null</span>,array);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> statusObject = &#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&#x27;A-OK&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// statusObject 并没有继承自 Quo.prototype，但我们可以在statusObject上调用</span></span><br><span class="line"><span class="comment">// get_status 方法，尽管 statusObject 并没有一个名为 get_status 的方法</span></span><br><span class="line"><span class="comment">// 原因就是 apply 调用将 get_status 内的 this 值绑定到传递给它的对象上了</span></span><br><span class="line">Quo.prototype.get_status.apply(statusObject);   <span class="comment">//=&gt; A-OK</span></span><br></pre></td></tr></table></figure>

<h3 id="关于返回值"><a href="#关于返回值" class="headerlink" title="关于返回值"></a>关于返回值</h3><p>一个函数总是会返回一个值。如果没有指定返回值，则返回 <code>undefined</code>。</p>
<p>如果函数调用时在前面加上了 <code>new</code>前缀，且返回值不是一个对象，则返回 <code>this</code>（该新对象）。</p>
<h3 id="扩展类型的功能"><a href="#扩展类型的功能" class="headerlink" title="扩展类型的功能"></a>扩展类型的功能</h3><p>JS允许给语言的基本类型扩充功能。例如通过给Function.prototype增加方法来使得该方法对所有函数可用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有在确定没有改方法时添加它</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name, func</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.prototype[name])&#123;</span><br><span class="line">        <span class="built_in">this</span>.prototype[name] = func;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript缺少一个移除字符串收尾空白的方法，可用这样弥补：</span></span><br><span class="line"><span class="comment">// 由于在ECMAScript 5 规范中，已经为String对象添加了trim方法，所以先检测有没有原生的</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">String</span>.trim)&#123;</span><br><span class="line">    <span class="built_in">String</span>.method(<span class="string">&#x27;trim&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;  aa &#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = str1.trim();</span><br><span class="line"><span class="built_in">console</span>.log(str1.length);     <span class="comment">// =&gt; 5</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.length);     <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>

<h3 id="递归（Recursion）"><a href="#递归（Recursion）" class="headerlink" title="递归（Recursion）"></a>递归（Recursion）</h3><h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><figure class="highlight javascript"><figcaption><span>汉诺塔问题的寻常解</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hanoi = <span class="function"><span class="keyword">function</span>(<span class="params">disc, src, aux, dst</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(disc &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        hanoi(disc-<span class="number">1</span>, src, dst, aux);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Move disc &#x27;</span>+ disc + <span class="string">&#x27; from &#x27;</span>+ src + <span class="string">&#x27; to &#x27;</span>+ dst);</span><br><span class="line">        hanoi(disc-<span class="number">1</span>, aux, src, dst);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hanoi(<span class="number">3</span>, <span class="string">&#x27;Src&#x27;</span>, <span class="string">&#x27;Aux&#x27;</span>, <span class="string">&#x27;Dst&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="DOM遍历"><a href="#DOM遍历" class="headerlink" title="DOM遍历"></a>DOM遍历</h4><p>递归函数可以非常高效地操作树形结构，比如浏览器端的文档对象模型（DOM）。每次递归调用时处理指定的树的一小段。下面的代码实际上解释了jQuery库中属性选择器的工作原理。</p>
<figure class="highlight javascript"><figcaption><span>DOM遍历代码示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> walk_the_DOM = <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">node, func</span>)</span>&#123;</span><br><span class="line">    func(node);</span><br><span class="line">    node = node.firstChild;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        walk(node, func);</span><br><span class="line">        node = node.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElementsByAttribute</span>(<span class="params">att, value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> results = [];</span><br><span class="line"></span><br><span class="line">    walk_the_DOM(<span class="built_in">document</span>.body, <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> actual = node.nodeType === <span class="number">1</span> &amp;&amp; node.getAttribute(att);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> actual === <span class="string">&#x27;string&#x27;</span> &amp;&amp; (actual === value || <span class="keyword">typeof</span> value !== <span class="string">&#x27;string&#x27;</span>))&#123;</span><br><span class="line">            results.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;#test_DOM_walker&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> text_success = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;---- ^_^ 嗯，找到这个id为test_myAttribute的元素节点了 ~~~~ &#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> text_failed  = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;---- 不妙，没有找到这个节点诶 ………… &#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> p = getElementsByAttribute(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;test_myAttribute&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            p.appendChild(text_success);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.appendChild(text_failed);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><button id="test_DOM_walker" type="button" class="btn btn-primary">运行测试代码</button></p>
<p id="test_myAttribute" class="output" myAttribute="x">some test paragraph.寻找本页面DOM中id属性为test_myAttribute的元素节点，如果成功找到了，就在本段落后面附上一段成功提示。否则，提示失败。</p>

<h4 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="尾递归优化"></a>尾递归优化</h4><figure class="highlight javascript"><figcaption><span>什么是尾递归？</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个尾递归</span></span><br><span class="line"><span class="keyword">var</span> factorial = <span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, a</span>)</span>&#123;</span><br><span class="line">    a = a || <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> factorial(n-<span class="number">1</span>, a*n);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的是n*fact(n-1)，而不是递归函数自身调用的结果</span></span><br><span class="line"><span class="comment">// 因此这个不是尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n*fact(n-<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>尾递归优化：如果一个函数返回自身递归调用的结果，那么这个调用的过程总是可以被替换为一个循环，从而可以显著提高速度，这就是尾递归优化。</p>
<p>不过貌似到目前为止，依旧没有任何JavaScript解释器提供尾递归优化。深度递归的函数可能会因为堆栈溢出而运行失败。</p>
<h3 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h3><p>函数作用域的好处是内部函数可以访问定义它们的外部函数的参数和变量（除了<code>this</code>和<code>arguments</code>）。</p>
<p>闭包的特征之一就是：</p>
<blockquote>
<p>内部函数拥有比它的外部函数更长的生命周期。</p>
</blockquote>
<p id="test_fade" class="output">点击下面按钮，本段落背景色先变黄，然后渐变为白色。</p>
<button id="button_test_fade" type="button" class="btn btn-primary" >运行背景色渐变代码</button>

<h3 id="模块（Module）"><a href="#模块（Module）" class="headerlink" title="模块（Module）"></a>模块（Module）</h3><blockquote>
<p>模块的一般形式是：一个定义了私有变量和函数的函数；利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把它保存到一个可访问的地方。</p>
<p>使用模块模式就可以摒弃全局变量的使用。它促进了信息隐藏和其他优秀的设计实践。对于应用程序的封装，或者构造其他单例对象，模块模式非常有用。</p>
</blockquote>
<h3 id="柯里化（curry）"><a href="#柯里化（curry）" class="headerlink" title="柯里化（curry）"></a>柯里化（curry）</h3><h3 id="记忆（Memoization）"><a href="#记忆（Memoization）" class="headerlink" title="记忆（Memoization）"></a>记忆（Memoization）</h3><p>记忆是一种优化方法：函数将先前操作的结果记录在某个对象里，从而避免无谓的重复运算。</p>
<figure class="highlight javascript"><figcaption><span>未经优化的Fibonacci数列计算</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 记录fibonacci 函数的调用次数</span></span><br><span class="line">    <span class="keyword">var</span> invocation_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        ++invocation_count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n&lt;<span class="number">2</span> ? n: fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;=<span class="number">10</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(fib(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(invocation_count);    <span class="comment">// =&gt; 453</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>使用闭包存储一个结果数组，每次调用fib函数时，先检查当前n值是否已经存在于数组中，如果已经存在，就立即返回这个结果。</p>
<figure class="highlight javascript"><figcaption><span>使用记忆方法对Fibonacci递归算法进行优化</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fibonacci = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> invocation_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> memo = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> res = memo[n];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> res !== <span class="string">&#x27;number&#x27;</span>)&#123;</span><br><span class="line">            res = fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">            memo[n] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        invocation_count++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;=<span class="number">10</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(fib(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(invocation_count);    <span class="comment">// =&gt; 29</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<h2 id="第5章-继承"><a href="#第5章-继承" class="headerlink" title="第5章 继承"></a>第5章 继承</h2><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>这一节的主要目的是，让大家不要使用伪类方式去实现继承。</p>
<h3 id="原型-1"><a href="#原型-1" class="headerlink" title="原型"></a>原型</h3><p>待细读。</p>
<h2 id="第6章-数组"><a href="#第6章-数组" class="headerlink" title="第6章 数组"></a>第6章 数组</h2><p>数组是特殊的对象。其效率比C语言的数组低很多。</p>
<h2 id="第7章-正则表达式"><a href="#第7章-正则表达式" class="headerlink" title="第7章 正则表达式"></a>第7章 正则表达式</h2><h2 id="第8章-方法"><a href="#第8章-方法" class="headerlink" title="第8章 方法"></a>第8章 方法</h2><p>没有太多特别的内容。类似犀牛书的第三部分。</p>
<h2 id="第9章-代码风格"><a href="#第9章-代码风格" class="headerlink" title="第9章 代码风格"></a>第9章 代码风格</h2><p>我觉得，更详细的内容可以参考<a href="http://book.douban.com/subject/21792530/" class="douban_book" name="21792530" target="_blank">《编写可维护的JavaScript》</a>。不过本章值得重新重视的还是有几点：</p>
<ul>
<li>在<code>if</code>和<code>(</code>之间放置一个空格，这样<code>if</code>就不会看起来像一个函数调用。只有真的是在调用一个函数时，才使<code>(</code>和其前面的符号相毗连。</li>
<li>把<code>&#123;</code>放在一行的结尾而不是下一行的开头，因为它会避免JavaScript的<code>return</code>语句中一个可怕的设计错误。</li>
<li>对一个脚本引用或工具库，只用唯一一个全局变量。使用闭包能提供进一步的信息隐藏，增强模块的健壮性。</li>
</ul>
<p>##第10章：优美的特性<br>一门语言是否具备为其自身编写一个编译器的能力，仍然是对这门语言完整性的一个测试。</p>
<blockquote>
<p>特性有规定成本、设计成本和开发成本，还有测试成本和可靠性成本。特性越多，某个特性出现问题，或者和其他特性相互干扰的可能性就越大。在软件系统中，存储成本是无足轻重的，但在移动应用中，它又变得重要了。它们抬高了电池的效能成本，因为摩尔定律并不适用于电池。</p>
</blockquote>
<script type="text/javascript">
//========= walk DOM 例子 =============
var walk_the_DOM = function walk(node, func){
    func(node);
    node = node.firstChild;
    while(node){
        walk(node, func);
        node = node.nextSibling;
    }
};

function getElementsByAttribute(att, value){
    var results = [];

    walk_the_DOM(document.body, function(node){
        var actual = node.nodeType === 1 && node.getAttribute(att);
        if(typeof actual === 'string' && (actual === value || typeof value !== 'string')){
            results.push(node);
        }
    });

    return results;
}

//===========  闭包，渐变背景色例子  ============
var fade = function(node){
    var level = 1;
    var step = function(){
        var hex = level.toString(16);
        node.style.background = '#FFFF' + hex + hex;
        if(level < 15){
            level += 1;
            setTimeout(step, 100);
        }
    };
    setTimeout(step, 100);
};

// ========== 注册事件处理函数 ===========
$(document).ready(function(){
    $('#test_DOM_walker').click(function(){
        var text_success = document.createTextNode('---- ^_^ 嗯，找到这个id为test_myAttribute的元素节点了 ~~~~ ');
        var text_failed  = document.createTextNode('---- 不妙，没有找到这个节点诶 ………… ');
        var p = getElementsByAttribute('id', 'test_myAttribute')[0];
        if(p){
            p.appendChild(text_success);
        }else{
            p.appendChild(text_failed);
        }
        
    });

    $('#button_test_fade').click(function(){
        var p = document.getElementById('test_fade');
        fade(p);
    });
});
</script>
        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="https://borninsummer.com/2014/01/02/reading-notes-on-javascript-the-good-parts/" data-id="cmb5bbmrq0061ttlecfch08cn" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2014/01/03/how-to-improve-12306/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Newer</strong>
            <div class="article-nav-title">
                
                    12306网站前端初步优化之我见
                
            </div>
        </a>
    
    
        <a href="/2013/12/30/html5-localstorage-study/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">html5 localStorage初探</div>
        </a>
    
</nav>


    
</article>


    
    
        <section id="comments">
	<div id="commentContainer"></div>
</section>
    

</section>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2025 zilong-thu<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a target="_blank" rel="noopener" href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        


    
    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>