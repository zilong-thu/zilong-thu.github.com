<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    
    <title>《JavaScript面向对象精要》笔记 | 王子龙的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="一切皆对象 其他编程语言用栈储存原始类型，用堆储存引用类型，JavaScript 则完全不同：它是以一个变量对象追踪变量的生存期。原始值被直接保存在变量对象内，而引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。page 2  例如，所有的 JavaScript 对象都有一个方法 Object.prototype.valueOf()，该方法返回指定对象的原始值。如果我们一">
<meta property="og:type" content="article">
<meta property="og:title" content="《JavaScript面向对象精要》笔记">
<meta property="og:url" content="https://borninsummer.com/2017/03/14/note-on-the-priciples-of-object-oriented-javascript/index.html">
<meta property="og:site_name" content="王子龙的博客">
<meta property="og:description" content="一切皆对象 其他编程语言用栈储存原始类型，用堆储存引用类型，JavaScript 则完全不同：它是以一个变量对象追踪变量的生存期。原始值被直接保存在变量对象内，而引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。page 2  例如，所有的 JavaScript 对象都有一个方法 Object.prototype.valueOf()，该方法返回指定对象的原始值。如果我们一">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2017-03-14T15:55:00.000Z">
<meta property="article:modified_time" content="2025-03-13T02:58:40.159Z">
<meta property="article:author" content="zilong-thu">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
    

    
        <link rel="alternate" href="/" title="王子龙的博客" type="application/atom+xml" />
    

    
        <link rel="icon" href="/favicon.png" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">


    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
    
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-45360338-1', 'auto');
ga('send', 'pageview');

</script>
    
    
    
        <script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?73ca1d91f31b2463befdc1c1827f2576";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>

    


<meta name="generator" content="Hexo 5.0.0"></head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">王子龙的博客</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
                    <a class="main-nav-link" href="/donate">Donate</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="https://borninsummer.com"></form>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                    <td><a class="main-nav-link" href="/donate">Donate</a></td>
                
                <td>
                    
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="https://borninsummer.com"></form>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            <section id="main"><article id="post-note-on-the-priciples-of-object-oriented-javascript" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            《JavaScript面向对象精要》笔记
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/03/14/note-on-the-priciples-of-object-oriented-javascript/">
            <time datetime="2017-03-14T15:55:00.000Z" itemprop="datePublished">2017-03-14</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/JavaScript/" rel="tag">JavaScript</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            <div id="toc" class="toc-article">
                <strong class="toc-title">Catalogue</strong>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">一切皆对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">2.</span> <span class="toc-text">JavaScript 只有值传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%89%B4%E5%88%AB%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">鉴别数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8D%B3%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.</span> <span class="toc-text">函数即对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">4.2.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind"><span class="toc-number">4.3.</span> <span class="toc-text">bind</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%8E%A2%E6%B5%8Bvs%E5%B1%9E%E6%80%A7%E5%80%BC%E6%8E%A2%E6%B5%8B"><span class="toc-number">5.1.</span> <span class="toc-text">属性探测vs属性值探测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">关于访问器属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%8D%B3%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">原型即对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%AE%89%E5%85%A8%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">作用域安全的构造函数</span></a></li></ol>
            </div>
            <h2 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h2><blockquote>
<p>其他编程语言用栈储存原始类型，用堆储存引用类型，JavaScript 则完全不同：它是以一个变量对象追踪变量的生存期。原始值被直接保存在变量对象内，而引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。<br>page 2</p>
</blockquote>
<p>例如，所有的 JavaScript 对象都有一个方法 <code>Object.prototype.valueOf()</code>，该方法返回指定对象的原始值。如果我们一个简单的赋值语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br></pre></td></tr></table></figure>

<p>那么我们会发现变量 <code>a</code> 上面其实有很多方法（当然，大部分都是来自于其原型）。这就是因为该变量是通过变量对象进行追踪的，并不仅仅只有一个值（这也涉及一个概念，“原始封装类型”）。这也是 JavaScript “一切皆为对象”的理念。</p>
<a id="more"></a>

<h2 id="JavaScript-只有值传递"><a href="#JavaScript-只有值传递" class="headerlink" title="JavaScript 只有值传递"></a>JavaScript 只有值传递</h2><p>我们知道，JavaScript 是只有值传递的。而下面的描述则更为深入地解释了内在机理：</p>
<blockquote>
<p>当你讲原始值赋给一个变量时，该值将被复制到变量中。也就是说，如果你使一个变量等于另一个时，每个变量有它自己的一份数据拷贝。<br>……每个含有原始值的变量使用自己的存储空间。<br>page 3</p>
</blockquote>
<h2 id="鉴别数组"><a href="#鉴别数组" class="headerlink" title="鉴别数组"></a>鉴别数组</h2><p><code>Array.isArray()</code> 方法是 ES5 标准所提出的。目前的支持度已经非常好。IE9+，Chrome/Safari/FireFox 都支持此 API。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数即对象"><a href="#函数即对象" class="headerlink" title="函数即对象"></a>函数即对象</h3><blockquote>
<p>函数其实就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为 <code>[[Call]]</code> 的内部属性。<br>……<code>[[Call]]</code> 是函数独有的，表明该对象可以被执行。由于仅函数拥有该属性，ECMAScript 定义 <code>typeof</code> 操作符对任何具有 <code>[[Call]]</code> 属性的对象返回 “function”。这在过去曾经导致一些问题，因为某些浏览器曾经在正则表达式中包含 <code>[[Call]]</code> 属性，导致后者被错误鉴别为函数。现在，所有浏览器行为都一致，<code>typeof</code> 不会再将正则表达式鉴别为函数了。</p>
</blockquote>
<p>函数是 JavaScript 语言的核心。一大特点就是：函数即对象。所以，函数可以被传递来传递去……</p>
<p>page 18 里面对函数声明、函数表达式进行了对比。不过，对于一个细节，并没有挖得很深。这里简单说一下，大概是“当我们说起函数作用域时，你可曾忘记了什么？”。考虑下面的一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var func = &#x27;test&#x27;;</span><br><span class="line"></span><br><span class="line">var func1 = function func(a) &#123;</span><br><span class="line">  console.log(typeof func);  // function</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1();</span><br><span class="line"></span><br><span class="line">console.log(func1.name);  // func</span><br></pre></td></tr></table></figure>

<p>一个函数字面量包含这几部分：</p>
<ul>
<li>关键字<code>function</code></li>
<li>空格</li>
<li>函数名（function name），非必须</li>
<li>(形参列表)</li>
<li>{函数体}</li>
</ul>
<p>其中，函数名、所有的形参，也都属于该函数作用域。这就是为什么在该函数内部，<code>func</code> 会屏蔽外部的变量。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数重载是一种设计目标，希望可以让一个函数具有多个签名。__函数签名__，是由函数名、参数个数、参数类型、返回值类型组成的。JavaScript 的函数其实根本没有签名，因为它对函数参数的数量与类型完全不做限制。对返回值的类型也一样，没有任何限制。所以可以说 JavaScript 函数是天然可重载的，也可以说 JavaScript 函数没有重载这个概念。</p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>JavaScript 函数的 <code>call</code>、<code>apply</code> 方法，都只是临时指定一个函数调用对象（<code>this</code>），但 ES5 所定义的新方法 <code>Function.prototype.bind()</code> 则差异较大。</p>
<ul>
<li><code>bind</code> 方法会返回一个新函数，并不会更改原始函数任何东西</li>
<li><code>bind</code> 不但会绑定 <code>this</code> 对象，同时也可以绑定参数，这两个被绑定后，绝大部分情况下是不可更改的</li>
<li>只有该新函数使用 new 操作符调用时，相应的 <code>this</code> 绑定会失效，但是其他的参数则依然是绑定着的。</li>
</ul>
<p>例如下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function say(label) &#123;</span><br><span class="line">  console.log(label + &#x27;: &#x27; + this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = &#123;</span><br><span class="line">  name: &#x27;person1&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * test 1</span><br><span class="line"> */</span><br><span class="line">var say1 = say.bind(person1, &#x27;say2&#x27;);</span><br><span class="line"></span><br><span class="line">say1(&#x27;say2222&#x27;);  // 会输出 say2: person1，而不是 say2222: person1</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * test 2</span><br><span class="line"> */</span><br><span class="line">var person2 = &#123;</span><br><span class="line">  name: &#x27;person2&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">say1.call(person2);  // 输出 say2: person1</span><br><span class="line"></span><br><span class="line">var p3 = new say1(&#x27;p3&#x27;);  // 输出：say2: undefined</span><br></pre></td></tr></table></figure>

<p>总结来说，<code>bind</code> 所产生的新函数，除非用 new 调用，是<strong>永久</strong>的。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="属性探测vs属性值探测"><a href="#属性探测vs属性值探测" class="headerlink" title="属性探测vs属性值探测"></a>属性探测vs属性值探测</h3><p>在实际的开发中，应当区分属性探测与属性值探测之间的区别。前者关注对象的某个属性是否存在、是否为自有（而非来自原型链），后者则关注属性的值（value）而非属性（property）本身。</p>
<p><code>in</code> 操作符是为了解决“对象的属性是否可达”这个问题而存在的。它完全不管属性指向的值。而<code>hasOwnProperty</code>则忽略原型链，只探测对象的自有属性。自有属性是 JavaScript 在对象上调用其内部接口 <code>[[PUT]]</code> 方法添加上的。</p>
<h3 id="关于访问器属性"><a href="#关于访问器属性" class="headerlink" title="关于访问器属性"></a>关于访问器属性</h3><p>对象的属性分为两类，第一类是最为常见的数据属性，<code>[[PUT]]</code> 方法默认创建的都是数据属性；另一类是访问器属性。访问器属性的一个例子如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  _name: &#x27;WangZilong&#x27;,</span><br><span class="line"></span><br><span class="line">  get name() &#123;</span><br><span class="line">    console.log(&#x27;you are getting name property.&#x27;);</span><br><span class="line">    return this._name;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    this._name = value;</span><br><span class="line">    console.log(&#x27;you have set a new name.&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obj.name);</span><br><span class="line"></span><br><span class="line">obj.name = &#x27;test&#x27;;</span><br><span class="line">console.log(obj.name);</span><br></pre></td></tr></table></figure>

<p>如果想实现一个PUB/SUB模式，又想偷懒，那么可以使用访问器属性。访问器属性是在 ES5 里定义的，除了 IE8及以下浏览器、iOS5.1及之前浏览器不支持之外，其他环境中基本都支持访问器属性。</p>
<p>其实，在前端生态圈里，avalon、vue 这样的 MVC 框架，就是使用了访问器属性（以及借助 <code>Object.defineProperty()</code> 方法），来实现所需的“双向绑定”功能。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote>
<p>每个对象在创建时都自动拥有一个构造函数属性，其中包含了一个指向其构造函数的引用。那些通过对象字面量形式或 <code>Object</code> 构造函数创建出来的范用对象，其构造函数属性指向 <code>Object</code>；那些通过自定义构造函数创建出来的对象，其构造函数属性指向创建它的构造函数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name: &#x27;obj&#x27;&#125;;</span><br><span class="line"></span><br><span class="line">obj.constructor;  // function Object() &#123; [native code] &#125;</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(&#x27;constructor&#x27;);  // 输出 false</span><br></pre></td></tr></table></figure>

<p>我们来针对 <code>constructor</code> 这个关键词/属性，延伸讨论一下。在 ES6 里面，明确了关键字 <code>class</code> 的用法：定义一个“类”，该类可以被 <code>new</code> 操作符调用，生成一个实例对象。</p>
<p>构造函数有个小特点：如果创建新实例时，没有什么参数需要传给构造函数，那么构造函数后面是可以不带圆括号的。例如日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = new Date;</span><br><span class="line"></span><br><span class="line">// 等价于：</span><br><span class="line">var a = new Date();</span><br></pre></td></tr></table></figure>

<p>但是，这样的编码是<strong>不清晰</strong>的！看不出来是函数调用。所以，不推荐省略圆括号。</p>
<h2 id="原型即对象"><a href="#原型即对象" class="headerlink" title="原型即对象"></a>原型即对象</h2><p>原型本质上也是对象。<strong>只有函数才有 <code>prototype</code> 属性。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name = name || &#x27;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var creature = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person.prototype = creature;</span><br><span class="line"></span><br><span class="line">var p = new Person(&#x27;Peter&#x27;);</span><br><span class="line"></span><br><span class="line">p.sayName();  // Peter</span><br><span class="line"></span><br><span class="line">console.log(p instanceof Person);  // true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person.prototype.sayAge = function() &#123;</span><br><span class="line">  if (this.age !== undefined) &#123;</span><br><span class="line">    console.log(&#x27;I am &#x27;, this.age, &#x27; years old.&#x27;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#x27;I do not know my age yet...&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.sayAge();  // I do not know my age yet...</span><br><span class="line"></span><br><span class="line">// 这个时候，creature 对象是 `sayAge` 方法的实际拥有者</span><br><span class="line">console.log(creature.hasOwnProperty(&#x27;sayAge&#x27;));  // true</span><br><span class="line">creature.isPrototypeOf(p);  // true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造函数、原型对象和对象实例之间的关系，最有趣的一个方面也许就是对象实例和构造函数之间没有直接关系。不过对象实例和原型对象，以及原型对象和构造函数之间都有直接联系。</p>
<p>—— page 59</p>
</blockquote>
<h2 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h2><p>构造函数应该都被写成作用域安全的。原因有这么几点：</p>
<ul>
<li>我们不知道代码是在严格还是非严格模式下运行。应该尽量为严格模式写代码。</li>
<li>无法保证调用构造函数的人乖乖地用 <code>new</code> 关键字调用。</li>
</ul>
<p>这样一来，构造函数就应该为上面的糟糕情况做准备。思路其实也很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  if (this instanceof Person) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 调用者忘记使用 new 关键字调用构造函数，那么我们替用户加上 new</span><br><span class="line">    return new Person(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="https://borninsummer.com/2017/03/14/note-on-the-priciples-of-object-oriented-javascript/" data-id="cmb5bbms300bqttle29esb3kb" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2017/03/20/koa-running-on-http2/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Newer</strong>
            <div class="article-nav-title">
                
                    Koa Running On HTTP/2
                
            </div>
        </a>
    
    
        <a href="/2017/03/12/linux-shell-scripting-2/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">Linux常用命令笔记（二：变量）</div>
        </a>
    
</nav>


    
</article>


    
    
        <section id="comments">
	<div id="commentContainer"></div>
</section>
    

</section>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2025 zilong-thu<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a target="_blank" rel="noopener" href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        


    
    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>