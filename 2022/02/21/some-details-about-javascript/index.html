<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    
    <title>JavaScript 的一些细节 | 王子龙的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="最近看了篇文章，「2021」高频前端面试题汇总之JavaScript篇（上），作者：CUGGZ，感觉文章不错，知识点很全。但是有些细节我研究了一下，对自己有些许帮助，特此记录下来。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 的一些细节">
<meta property="og:url" content="https://borninsummer.com/2022/02/21/some-details-about-javascript/index.html">
<meta property="og:site_name" content="王子龙的博客">
<meta property="og:description" content="最近看了篇文章，「2021」高频前端面试题汇总之JavaScript篇（上），作者：CUGGZ，感觉文章不错，知识点很全。但是有些细节我研究了一下，对自己有些许帮助，特此记录下来。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-02-21T05:09:04.000Z">
<meta property="article:modified_time" content="2025-03-13T02:58:40.169Z">
<meta property="article:author" content="zilong-thu">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
    

    
        <link rel="alternate" href="/" title="王子龙的博客" type="application/atom+xml" />
    

    
        <link rel="icon" href="/favicon.png" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">


    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
    
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-45360338-1', 'auto');
ga('send', 'pageview');

</script>
    
    
    
        <script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?73ca1d91f31b2463befdc1c1827f2576";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>

    


<meta name="generator" content="Hexo 5.0.0"></head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">王子龙的博客</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
                    <a class="main-nav-link" href="/donate">Donate</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="https://borninsummer.com"></form>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                    <td><a class="main-nav-link" href="/donate">Donate</a></td>
                
                <td>
                    
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="https://borninsummer.com"></form>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            <section id="main"><article id="post-some-details-about-javascript" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            JavaScript 的一些细节
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2022/02/21/some-details-about-javascript/">
            <time datetime="2022-02-21T05:09:04.000Z" itemprop="datePublished">2022-02-21</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/JavaScript/" rel="tag">JavaScript</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            <div id="toc" class="toc-article">
                <strong class="toc-title">Catalogue</strong>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-null-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">typeof null 的结果是什么，为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined-%E4%B8%8D%E6%98%AF%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">2.</span> <span class="toc-text">undefined 不是保留字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-ToPrimitive-%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">关于 ToPrimitive 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84-rest-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">数组的 rest 操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-Proxy"><span class="toc-number">5.</span> <span class="toc-text">关于 Proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">1. 访问已存在的嵌套对象的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%B5%8C%E5%A5%97%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.2.</span> <span class="toc-text">2. 动态添加嵌套的对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E5%8F%96%E6%B7%B1%E5%BA%A6%E5%B5%8C%E5%A5%97%E7%9A%84%E5%AF%B9%E8%B1%A1%E9%87%8C%E7%9A%84%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">如何提取深度嵌套的对象里的指定属性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E3%80%81Map-%E5%92%8C-WeakMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">Object、Map 和 WeakMap 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defer-%E4%B8%8E-async-%E5%B1%9E%E6%80%A7"><span class="toc-number">8.</span> <span class="toc-text">defer 与 async 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-amp-amp-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">|| 和 &amp;&amp; 操作符的返回值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-Unicode"><span class="toc-number">10.</span> <span class="toc-text">关于 Unicode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#encodeURIComponent-%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">encodeURIComponent 在干什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E6%9D%A5%E8%81%8A%E8%81%8A-async%E3%80%81await-%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">12.</span> <span class="toc-text">再来聊聊 async、await 与事件循环</span></a></li></ol>
            </div>
            <p>最近看了篇文章，<a target="_blank" rel="noopener" href="https://juejin.cn/post/6940945178899251230">「2021」高频前端面试题汇总之JavaScript篇（上），作者：CUGGZ</a>，感觉文章不错，知识点很全。但是有些细节我研究了一下，对自己有些许帮助，特此记录下来。</p>
<a id="more"></a>

<h2 id="typeof-null-的结果是什么，为什么？"><a href="#typeof-null-的结果是什么，为什么？" class="headerlink" title="typeof null 的结果是什么，为什么？"></a>typeof null 的结果是什么，为什么？</h2><blockquote>
<p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：<br>000: object   - 当前存储的数据指向一个对象。<br>1: int      - 当前存储的数据是一个 31 位的有符号整数。<br>010: double   - 当前存储的数据指向一个双精度的浮点数。<br>100: string   - 当前存储的数据指向一个字符串。<br>110: boolean  - 当前存储的数据是布尔值。<br>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。<br>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p>
</blockquote>
<p>其实上面说了程序方面的实现，而 Breidan 本人则没想那么多，就是把 null 按照 Object 来实现的。</p>
<h2 id="undefined-不是保留字"><a href="#undefined-不是保留字" class="headerlink" title="undefined 不是保留字"></a><code>undefined</code> 不是保留字</h2><p><code>undefined</code> 在 JS 语言里不是保留字，意味着 undefined “可以”当做标识符使用，可以被赋值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>但是，上面的语句会自动失效，即 <code>undefined</code> 的值依然是 <code>undefined</code>，与 <code>（void 0）</code> 的返回值一样。</p>
<h2 id="关于-ToPrimitive-方法"><a href="#关于-ToPrimitive-方法" class="headerlink" title="关于 ToPrimitive 方法"></a>关于 <code>ToPrimitive</code> 方法</h2><p>原生 JS 里不存在这个全局方法，而是内置（即不对外暴露）在每个 JS 值上的：<code>Symbol.ToPrimitive</code>。定义：</p>
<blockquote>
<p>The Symbol.toPrimitive is a symbol that specifies a function valued property that is called to convert an object to a corresponding primitive value.</p>
</blockquote>
<p>举个例子（MDN 官方例子）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hint === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(object1));  <span class="comment">// 输出 42</span></span><br></pre></td></tr></table></figure>

<h2 id="数组的-rest-操作符"><a href="#数组的-rest-操作符" class="headerlink" title="数组的 rest 操作符"></a>数组的 rest 操作符</h2><p><code>Math.min()</code> 与 <code>Math.max()</code> 都是可以接受任意个数参数的，因此如果是数组，可以借助 rest 操作符展开数组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.min(...arr));  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr));  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<h2 id="关于-Proxy"><a href="#关于-Proxy" class="headerlink" title="关于 Proxy"></a>关于 Proxy</h2><p>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p>
<p>基本语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">next</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;key: &#x27;</span>, key, <span class="string">&#x27; =&gt; &#x27;</span>, value);</span><br><span class="line">    target[key] = value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;trying to get&#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>target</code>: 被 Proxy 代理虚拟化的对象，可以是任何类型的对象，包括原生数组，函数，甚至另一个代理。它常被作为代理的存储后端。——这里的“存储后端”，意味着我们实际使用时，一般通过 <code>p</code> 来访问、操作对象，而非使用 <code>target</code>。</li>
<li><code>handler</code>: 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</li>
</ul>
<p>不过，<code>p instanceof Proxy</code> 却会报错，<code>p instanceof Object</code> 则正常返回 <code>true</code>。</p>
<p><code>Proxy</code> 的兼容性肯定是越来越好，PC 端、主流的移动设备，基本问题不大了。</p>
<p>一个更细节的问题：使用 <code>Proxy</code> 能否监听嵌套的对象？</p>
<h3 id="1-访问已存在的嵌套对象的属性"><a href="#1-访问已存在的嵌套对象的属性" class="headerlink" title="1. 访问已存在的嵌套对象的属性"></a>1. 访问已存在的嵌套对象的属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p.next.name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问正常</span></span><br><span class="line"><span class="comment">// 输出 trying to get next 以及对应的值</span></span><br></pre></td></tr></table></figure>

<h3 id="2-动态添加嵌套的对象"><a href="#2-动态添加嵌套的对象" class="headerlink" title="2. 动态添加嵌套的对象"></a>2. 动态添加嵌套的对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.child = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.child.name);</span><br></pre></td></tr></table></figure>

<p>也是能正常操作的。</p>
<h2 id="如何提取深度嵌套的对象里的指定属性？"><a href="#如何提取深度嵌套的对象里的指定属性？" class="headerlink" title="如何提取深度嵌套的对象里的指定属性？"></a>如何提取深度嵌套的对象里的指定属性？</h2><p>这个比较有意思。解构赋值在处理层级较浅的对象时很清晰，但是如果对象层级比较深，其实也是有办法解构的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">   <span class="attr">classes</span>: &#123;</span><br><span class="line">      <span class="attr">stu</span>: &#123;</span><br><span class="line">         <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">         <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">classes</span>: &#123; <span class="attr">stu</span>: &#123; name &#125; &#125;&#125; = school;</span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// Bob</span></span><br></pre></td></tr></table></figure>

<p>注意此时其他的层级（例如 classes、stu）都不是解构赋值，即解构赋值仅作用于最末层。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(stu);  <span class="comment">// Uncaught ReferenceError: stu is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="Object、Map-和-WeakMap-的区别"><a href="#Object、Map-和-WeakMap-的区别" class="headerlink" title="Object、Map 和 WeakMap 的区别"></a><code>Object</code>、<code>Map</code> 和 <code>WeakMap</code> 的区别</h2><p>这个比较还是比较重要的，说明了 JS 语言是在进步的。</p>
<ul>
<li>意外的键：Map 默认情况不包含任何键，只包含显式插入的键。一个 Object 有一个原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突，用 Object.create(null) 可以创建一个没有原型的对象。</li>
<li>键的类型：一个 Map的键可以是任意值，包括函数、对象或任意基本类型。一个Object 的键必须是一个 String 或是Symbol。</li>
<li>键的顺序： Map 中的 key 是有序的。因此，当迭代的时候，一个 Map 对象以插入的顺序返回键值。一个 Object 的键则是无序的，但是自 ECMAScript 2015规范以来，对象确实保留了字符串和Symbol键的创建顺序，因此，在只有字符串键的对象上进行迭代将按插入顺序产生键。</li>
<li>Size：Map 的键值对个数可以轻易地通过 size 属性获取。Object 的键值对个数可以通过 Object.keys(obj).length 计算。</li>
<li>遍历： Map 是 iterable 的，所以可以直接被迭代。迭代一个Object需要以某种方式获取它的键然后才能迭代，<code>for...in</code>，或者 <code>Object.keys()</code>。</li>
<li>性能： Map 在频繁增删键值对的场景下表现更好。Object 在频繁添加和删除键值对的场景下未作出优化。</li>
</ul>
<p><code>Map</code> 的存储结构可以用数组来理解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = [</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;age&quot;</span>,<span class="number">18</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><code>Map</code> 构造函数也可以接受一个二维数组来初始化一个实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;l&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;age&#x27;</span>, <span class="number">19</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h2 id="defer-与-async-属性"><a href="#defer-与-async-属性" class="headerlink" title="defer 与 async 属性"></a><code>defer</code> 与 <code>async</code> 属性</h2><p><code>script</code> 标签的 <code>defer</code> 属性会让脚步先下载，但是在文档解析后再执行。一般来说是按顺序执行的。</p>
<p><code>async</code> 属性则让脚步异步加载（也是先下载），但是脚步加载完后立即解析执行。</p>
<p>因此两个属性一起用比较合适，尤其针对错误监控、数据统计类的 SDK，它们往往不是业务必须的，可以采取种子脚本 + <code>&lt;script src=&quot;path-to-js&quot; defer async&gt;&lt;/script&gt;</code> 的方式加载。</p>
<h2 id="和-amp-amp-操作符的返回值？"><a href="#和-amp-amp-操作符的返回值？" class="headerlink" title="|| 和 &amp;&amp; 操作符的返回值？"></a><code>||</code> 和 <code>&amp;&amp;</code> 操作符的返回值？</h2><p>这个问题的细节就是，这两个操作符并非返回布尔类型，而是返回其左右两侧之一的值（从而是该值的类型）。举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> (<span class="number">1</span> || <span class="number">2</span>);  <span class="comment">// =&gt; number</span></span><br></pre></td></tr></table></figure>

<h2 id="关于-Unicode"><a href="#关于-Unicode" class="headerlink" title="关于 Unicode"></a>关于 Unicode</h2><p>Unicode 的官网 <a target="_blank" rel="noopener" href="https://home.unicode.org/">home.unicode</a> 有一句宣传语：</p>
<blockquote>
<p>Everyone in the world should be able to use their own language on phones and computers.</p>
</blockquote>
<p><code>UTF</code> 是 Unicode Transformation Format 的缩写。即描述的是编码方式，而非符号集本身。</p>
<p>Unicode 使用 6 个 16 进制字符来表示全世界所有的字符。但是前两位是固定的，用来表示“平面”。因此其可以表达的字符个数 = 平面树 * 16 ^ 4。</p>
<p>前面两个 16 进制位理论上可以支持 256 个平面，不过 Unicode 的选择是只设计了 17 个平面。</p>
<p>因此 Unicode 可以表达的字符数 = 17 *  16 ^ 4 = 1114112。即大约 111 万个字符。</p>
<p>这一块，看到的一个通俗易懂的博客：<a target="_blank" rel="noopener" href="https://lunawen.com/basics/20201129-luna-tech-unicode-plane/">Unicode - 平面（Plane）的概念 | Luna Tech</a>。</p>
<h2 id="encodeURIComponent-在干什么？"><a href="#encodeURIComponent-在干什么？" class="headerlink" title="encodeURIComponent 在干什么？"></a><code>encodeURIComponent</code> 在干什么？</h2><p>准确地说，<code>encodeURIComponent</code> 可以将 <code>A-Z a-z 0-9 - _ . ! ~ * &#39; ( )</code> 之外的所有字符转换为 <code>utf-8</code> 字符序列（每个字符前以 <code>%</code> 开头）。举个例子，我们对等于号 <code>=</code> 进行 <code>encodeURIComponent</code> 编码。</p>
<p><code>=</code> 在 ASCII 码和 Unicode 字符集中的编码都是 61，用 16 进制表示就是 3D，那么 <code>encodeURIComponent</code> 之后应该就是 <code>%3D</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;=&#x27;</span>));  <span class="comment">// %3D</span></span><br></pre></td></tr></table></figure>

<h2 id="再来聊聊-async、await-与事件循环"><a href="#再来聊聊-async、await-与事件循环" class="headerlink" title="再来聊聊 async、await 与事件循环"></a>再来聊聊 async、await 与事件循环</h2><p>这个文章比较狠：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904077537574919">【建议星星】要就来45道Promise面试题一次爽到底(1.1w字用心整理)</a>。确实很良心，能让人把异步编程吃透了。文章信息：</p>
<blockquote>
<p>作者：LinDaiDai_霖呆呆<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904077537574919">https://juejin.cn/post/6844904077537574919</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>总而言之，关键点：</p>
<ul>
<li><code>Promise.then()</code> 或 <code>catch()</code> 会创造一个微任务，放在当前事件循环的尾部来执行。</li>
<li><code>process.nextTick()</code> 也会创建一个微任务，</li>
<li><code>.then</code> 或者 <code>.catch</code> 中 <code>return</code> 一个 <code>Error</code> 对象并不会抛出错误，所以不会被后续的 <code>.catch</code> 捕获。</li>
<li>在 <code>Promise</code> 中，返回任意一个非 <code>Promise</code> 的值都会被包裹成 <code>Promise</code> 对象。</li>
<li><code>Promise</code> 的状态一经改变就不能再改变。</li>
</ul>
<p><code>process.nextTick</code> 的工作细节，在 Node 的官网里有详细介绍：</p>
<blockquote>
<p>Every time the event loop takes a full trip, we call it a tick.<br>When we pass a function to <code>process.nextTick()</code>, we instruct the engine to invoke this function at the end of the current operation, before the next event loop tick starts.<br>The event loop is busy processing the current function code.<br>When this operation ends, the JS engine runs all the functions passed to nextTick calls during that operation.<br>It’s the way we can tell the JS engine to process a function asynchronously (after the current function), but as soon as possible, not queue it.<br>—— from <a target="_blank" rel="noopener" href="https://nodejs.dev/learn/understanding-process-nexttick">Understanding process.nextTick()</a></p>
</blockquote>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="https://borninsummer.com/2022/02/21/some-details-about-javascript/" data-id="cmb5bbmsg00hhttleaazydowr" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2022/05/28/about-stock-bonus/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Newer</strong>
            <div class="article-nav-title">
                
                    说说今年的股票分红
                
            </div>
        </a>
    
    
        <a href="/2022/02/12/note-on-book-one-up-on-wall-street/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">《彼得·林奇的成功投资》读书笔记</div>
        </a>
    
</nav>


    
</article>


    
    
        <section id="comments">
	<div id="commentContainer"></div>
</section>
    

</section>
            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2025 zilong-thu<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a target="_blank" rel="noopener" href="http://github.com/ppoffice">PPOffice</a>
        </div>
    </div>
</footer>
        


    
    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>