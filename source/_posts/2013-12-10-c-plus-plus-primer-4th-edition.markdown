---
layout: post
title: "《C++ Primer》笔记"
date: 2013-12-10 19:37
comments: true
keywords: c++ primer 4th edition, c++ primer中文版第四版, 学习笔记
categories: CPP
---
三年前就买了<a href="http://book.douban.com/subject/1767741/" class="douban_book" name="1767741" target="_blank">《C++ Primer·中文版·第四版》</a>，但只是把它当做偶尔翻翻的工具书，一直没认真读。接下来的几个月得做硕士论文的课题，又不想继续像以前那样对C++浑浑噩噩地使用，所以，计划用30天的时间，读一遍这本书。

目标：粗读，复习标准库类型、类、容器，学习泛型编程，尽可能细读高级主题。

<!--more-->
##Chapter 2. 变量和基本类型
C++是一门静态类型语言，在编译时会做类型检查。

###一些基本概念。
<dl>
<dt>左值</dt>
<dd>左值可以出现在赋值语句的左边或右边。例如变量（variable）。</dd>
<dt>右值</dt>
<dd>右值只能出现在赋值语句的右边，不能出现在赋值语句的左边。例如字面量常值（literal constant）。</dd>
<dt>对象</dt>
<dd>一般而言，对象（object）就是内存中具有类型的区域。具体一些，计算左值表达式就会产生对象。</dd>
<dt>定义</dt>
<dd>为了让多个文件访问相同的变量，C++区分了声明和定义。变量的定义（definition）用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。在C++中，变量必须且仅能定义一次，而且在使用变量之前必须定义或声明变量。</dd>
<dt>声明（declaration）</dt>
<dd>声明用于向程序表明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。程序中变量可以声明多次，但只能定义一次。如果声明有初始化式，那么它可以被当做是定意思，即使声明标记为extern。</dd>
</dl>

###关于作用域
C++的作用域研究的是“名字”，而非“变量”。作用域：用来区分名字的不同意义的上下文称为作用域（scope）。

<dl>
<dt>全局作用域</dt>
<dd>global scope，定义在所有函数之外的名字，具有全局作用域。</dd>
<dt>局部作用域</dt>
<dd>local scope。出现在for(){}循环的条件语句中。</dd>
<dt>语句作用域</dt>
<dd>statement scope</dd>
<dt>类作用域</dt>
<dd>class scope</dd>
<dt>命名空间作用域</dt>
<dd>namespace scope</dd>
</dl>

###const限定符
`const`限定符把一个对象`o`转换成一个常量，但这个对象依然是一个左值。

const对象默认为文件的局部变量。要使const变量能够在其他的文件中访问，必须显式地指定它为`extern`（非const变量默认为extern）。

###引用
<strong>引用（reference）就是对象的另一个名字。</strong>

在实际程序中，引用主要用作函数的形式参数。引用是一种复合类型（compound type），通过在变量名前添加`&`符号来定义。JavaScript是词法作用域，非常简单。C++……好复杂啊。我得弄个abc的例子提醒一下自己了：
``` cpp
#include <iostream>
using namespace std;

void func(int &a, int b);

int main(){
	int a=0, b=1, c=3;
	for (int d=0; d<3; d++){
		a += d;
	}

	cout<< "a = " <<a<<endl;    // => a = 3
	func(a,b);
	cout<< "a = " <<a<<endl;    // => a = 4
	return 0;
}

void func(int &a, int b){
	a = a+b;
}
```

##Chapter 3. 标准库类型
两种最重要的标准库类型是`string`和`vector`。`string`类型支持长度可变的字符串，`vector`可用于保存一组指定类型的对象。

###string类
字符串的下标操作的返回值是个左值。
``` cpp
string str("Ha");
str[1] = 'f';             // => str变成"Hf"
```

C++的一个不足是，字符串字面值之间无法连接：

``` cpp
// VS2010下会这样报错
// error C2110: “+”: 不能添加两个指针
string s3 = "i am a string." + "ss";
```
总的来说（以我目前掌握的知识水平来判断），与JavaScript相比，string不够强大，但相比于C确实是很不错了。希望以后C++标准库能够更强吧。

###vector类模板
vector是同一类型的对象的集合，每个对象都有一个对应的整数索引值。

vector是一个类模板（class template）。vector不是一种数据类型。

vector对象（以及其他标准库容器对象）的重要属性就在于可以在运行时高效地添加元素。

vector中的对象是没有命名的，只能通过下标进行访问。与string类型的下标操作符一样，vector下标操作的返回值也是一个左值，因此可以进行写入（通过复制操作）。

作者说：“像size()这样的小库函数几乎都定义为内联函数，所以每次循环过程中调用它的运行时代价是比较小的。”我对此比较疑惑，因为在JavaScript中，这种类似size()的运算与读取变量值相比，都是要消耗更多性能的。不过后来大牛说C++中这样做确实不太消耗性能，就释然了。只是不明白size()如何实现的。

###缓冲区溢出
vector容器的下标操作不能进行元素添加操作。

试图对不存在的元素进行下标操作是程序设计过程中经常会犯的严重错误。所谓的“缓冲区溢出”错误就是对不存在的元素进行下标操作的结果。这样的缺陷往往导致PC机和其他应用中最常见的安全问题。

> 总的来说，相对于C++内置数据类型的数组和指针而言，程序员应优先使用标准库类类型。设计良好的程序只有在强调速度时才在类实现的内部使用数组和指针。

##Chapter 4. 数组和指针
与vector类型相比，数组的显著缺陷在于：数组的长度是固定的，而且程序员无法知道一个给定数组的长度。数组没有获取其容量大小的size操作，也不提供push_back操作在其中自动添加元素。如果需要更改数组长度，程序员只能创建一个更大的数组，然后把原数组的所有元素复制到新数组空间中去。

###数组的定义和初始化
数组的维数必须用值大于1的常量表达式。此常量表达式只能包含整型字面值常量、枚举常量或者用常量表达式初始化的整型const对象。非const变量以及要到运行阶段才知道其值的const变量都不能用于定义数组的维数。

`&`符号是取地址（address-of）操作符，当次操作符用于一个对象上时，返回的是该对象的存储地址。取地址操作只能用于左值，因为只有当变量用作左值时，才能取其地址。

<strong>建议：尽量避免使用指针和数组。</strong>

###指针

C++不允许void*指针操作它指向的对象。

``` cpp string变量的可以随时动态修改的
void func(){
	string s("this is some text.");
	string *ps = &s;
	cout <<"length of string \""<< (*ps) <<"\" is "<<(*ps).size() <<endl;

	*ps = "goodbye";
	cout <<"length of string \""<< s <<"\" is "<<s.size() <<endl;
}

// 运行结果：
// length of string "this is some text." is 18
// length of string "goodbye" is 7
```
####指针和引用的比较
使用引用和指针都可以间接访问另一个值，但二者存在重要区别：

+ 引用总是指向某个对象：定义引用时没有初始化是错误的。指针指向的对象不是固定的。
+ 赋值行为的差异：给引用赋值，修改的是该引用所关联的对象的值，而不是使引用于另一个对象关联；但是对指针赋值，修改的是指针关联的对象。引用一经初始化，就始终指向同一个特定对象。

####指向指针的指针
指针指向对象，那么也有指向指针的指针，以及指向指向指针的指针的指针，如此无限类推。所以说，指针最大优点也仅仅是提高运行效率，就没啥优点了——实在是太靠近硬件了。
``` cpp
int i =42,j=1024;
int *p1 = &i, *p2 = &j;
int **pp1 = &p1;
int ***ppp1 = &pp1;
int ****pppp1 = &ppp1;
cout<<"pppp1: "<< ****pppp1<<endl;    // => pppp1: 42
```
####指针减法
数组size()运算返回值类型是标准库类型中的size_t类型，指针相减运算的返回值是标准库类型的ptrdiff_t类型数据。这两种类型都是与机器相关的类型。size_t是unsigned类型，而ptrdiff_t是signed整型。

这两种类型的差别体现了它们各自的用途：size_t类型用于指明数组长度，因而必须是整数；ptrdiff_t类型则应保证足以存放同一数组中两个指针之间的差距，有可能是负数。

####指针与const限定符
二者之间有两种交互类型：指向const对象的指针，const指针。

``` cpp 指向const对象的指针
const double pi = 3.14159;
double *ptr = &pi;             // => error
const double *cptr = &pi;      // => ok: cptr is a pointer to const
```

const指针是本身的值不能修改的指针。

###动态数组
堆（heap）或自由存储区（free store）：每个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区或堆。

##Chapter 5. 表达式

+ 一元操作符，unary operator
+ 二元操作符，binary operator
+ 三元操作符，ternary operator

###逻辑操作符
逻辑或、逻辑与的求值策略也是“短路求值”（short-circuit evaluation）。即只有在左操作数的值无法确定整个逻辑表达式的值时，才会求解右操作数。

``` cpp 将一个句子的第一个单词的各字符全部变成大写
string s = "You can create art and beauty on a computer.";
string::iterator itr = s.begin();
while( itr != s.end() && !isspace(*itr)){
	*itr = toupper(*itr);
	++itr;
}
```

###赋值操作符
赋值操作具有右结合性。<strong>赋值表达式的值是其左操作数的值，其结果的类型是左操作数的类型。</strong>——这一点与JavaScript截然相反，对于后者而言，赋值表达式的值是右操作数的值。（可参考：<a href="http://book.douban.com/annotation/29593293/" target="_blank">《JavaScript DOM编程艺术》的笔记-第23页</a>）
``` cpp
int ival = 0, eval;
eval = ival = 3.14159;
cout <<"ival = "<<ival<<endl;      // => ival = 3
cout <<"eval = "<<eval<<endl;      // => eval = 3
```
####复合赋值操作符
记住5种复合算术操作符即可：

	+=    -=    /=    %=    *=
###自增、自减操作符
作者提到二者的性能区别，并建议尽可能只使用前置操作符，原因如下：前置操作需要做的工作更少，只需要加1然后返回修改后的值即可；而后置操作符则必须先保存操作数原来的值，以便返回未加1之前的值作为表达式的结果。对于int型对象和指针，编译器可优化掉这项额外工作。但是对于更多的复杂迭代器类型，这种额外工作可能会花费更大的代价。因此，养成使用前置操作这个好习惯，就不必操心性能差异的问题。

后自增操作的优先级高于解引用操作，所以`*iter++`等效于`*(iter++)`。
###箭头操作符
箭头操作符是包含点操作符和解引用操作符表达式的同义词。

###条件操作符
即那个唯一的三元操作符。作者给出一个建议：避免条件操作符的深度嵌套。但<strong>没有给出原因</strong>，我想大概是因为太难懂。

####求值顺序
C++中，规定了操作数的计算顺序的操作符只有：

+ 逻辑与 `&&`
+ 逻辑或 `||`
+ 条件操作符 `?:`
+ 逗号操作符

除此之外，其他操作符并未制定其操作数的求值顺序。

> 其实，以什么方式求解操作数通常没有多大关系。只有当操作符的两个操作数设计到同一个对象，并改变其值时，操作数的计算顺序才会影响结果。

###类型转换
如果两个类型之间可以相互转换（conversion），则称这两个类型相关。

####隐式类型转换（implicit type conversion）
在赋值操作中，因为不可能更改左操作数对象的类型，因此左操作数的类型占主导地位。如果赋值操作的左右操作数类型不同，则右操作数会被转换为左边的类型。

算数转换（arithmetic conversion）：转换规则最重要的一点是要确保计算值的精度。

算数类型与布尔类型的转换：将算数类型转换为bool类型时，零转换为false，而其他值则转换为true。将bool对象转换为算数类型时，true变成1，而false则为0.
``` cpp
bool b;
b = -1;
cout<<b;    // =>  1
```

####强制类型转换
作者建议避免使用强制类型转换，因为强制类型转换关闭或挂起了正常的类型检查。不依赖强制类型转换也能写出很好的C++程序。

##Chapter 6. 语句
###空语句
如果在程序的某个地方，语法上需要一个语句，但逻辑上并不需要，此时应该使用空语句。这种用法常见于在循环条件判断部分就能完成全部循环工作的情况。例如：
``` cpp
// read until we hit end-of-file or find an input equal to sought
while(cin>>s && s!=sought) ;

###复合语句
复合语句（compound statement），通常被称为块（block），是用一对花括号括起来的语句序列。块标识了一个作用域，在块中引入的名字只能在该块内部或嵌套在块中的子块里访问。通常，一个名字只从其定义处到该块的结尾这段范围内可见。

<strong>块并不是以分号结束的。</strong>于是`{}`就相当于空语句`;`了。

###switch语句
switch语句花括号、case标号都必须是整型常量表达式。包括整数、枚举类型。

如果需要为某个特殊的`case`定义变量，则可以引入块语句，在该块语句中定义变量，从而保证这个变量在使用前被定义和初始化。

###for语句
for语句头必须是声明语句、表达式语句或空语句（这些语句都以分号结束）；而不能是复合语句、条件语句等。

for语句头中可以定义多个对象；但是不管怎样，该处只能出现一个语句，因此所有的对象必须具有相同的一般类型。

##Chapter 7. 函数


##书评
本书大而全，是优点，亦是缺点。

糟粕：

+ 数组与指针，完全属于C语言的东西，虽说C++对C完全兼容，但也不应该放在C++书里介绍。真正的C++程序员会尽量避免使用指针与数组；大量使用指针与数组的程序员是C程序员，如果他还偶尔使用类，那就是C-C++程序员。所以，这是糟粕一：这本书不但介绍了指针与数组，还建议读者尽量不要使用它们——这也许是写手册类书籍的惯例。

学C++的好处

+ 很多数据结构、算法的书籍是用C或C++写的，所以，学习C++可以提升你在看这些书籍时的自信，或者说减少读这些书籍的阻碍。